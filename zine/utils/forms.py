# -*- coding: utf-8 -*-
"""
    zine.utils.forms
    ~~~~~~~~~~~~~~~~

    This module implements a sophisticated form validation and rendering
    system that is based on diva with concepts from django newforms and
    wtforms incorporated.

    It can validate nested structures and works in both ways.  It can also
    handle intelligent backredirects (via :mod:`zine.utils.http`) and supports
    basic CSRF protection.

    For usage informations see :class:`Form`

    :copyright: Copyright 2007-2008 by Armin Ronacher, Christopher Lenz.
    :license: GNU GPL.
"""
import re
from datetime import datetime
from unicodedata import normalize
from itertools import chain
try:
    from hashlib import sha1
except ImportError:
    from sha import new as sha1

from werkzeug import html

from zine.application import get_request, url_for
from zine.i18n import _, ngettext, parse_datetime, format_system_datetime
from zine.utils.http import get_redirect_target, redirect


class DataIntegrityError(ValueError):
    """Raised if data was fed to the form handling system that was not
    generated by it.
    """


def _decode(data):
    """Decodes the flat dictionary d into a nested structure.

    >>> _decode({'foo': 'bar'})
    {'foo': 'bar'}

    >>> _decode({'foo.0': 'bar', 'foo.1': 'baz'})
    {'foo': ['bar', 'baz']}

    >>> data = _decode({'foo.bar': '1', 'foo.baz': '2'})
    >>> assert data == {'foo': {'bar': '1', 'baz': '2'}}

    >>> _decode({'foo.bar.0': 'baz', 'foo.bar.1': 'buzz'})
    {'foo': {'bar': ['baz', 'buzz']}}

    >>> _decode({'foo.0.bar': '23', 'foo.1.baz': '42'})
    {'foo': [{'bar': '23'}, {'baz': '42'}]}

    >>> _decode({'foo.0.0': '23', 'foo.0.1': '42'})
    {'foo': [['23', '42']]}

    >>> _decode({'foo': ['23', '42']})
    {'foo': ['23', '42']}
    """
    list_marker = object()
    result = {}
    lists = []

    for key, value in data.iteritems():
        if '.' not in key:
            result[key] = value
        else:
            names = key.split('.')
            container = result
            end = len(names) - 1
            for idx in xrange(end):
                curname = names[idx]
                if curname not in container:
                    nextname = names[idx + 1]
                    container[curname] = {}
                    if nextname.isdigit():
                        container[curname][list_marker] = True
                container = container[curname]
            if isinstance(container, dict):
                container[names[-1]] = value

    def _convert(data):
        if type(data) is dict:
            if data.pop(list_marker, False):
                data = [_convert(v) for k, v in sorted(data.items())]
            else:
                data = dict((k, _convert(v)) for k, v in data.iteritems())
        return data

    return _convert(result)


def _bind(obj, form, memo):
    """Helper for the field binding.  This is inspired by the way `deepcopy`
    is implemented.
    """
    if memo is None:
        memo = {}
    obj_id = id(obj)
    if obj_id in memo:
        return memo[obj_id]
    rv = obj._bind(form, memo)
    memo[obj_id] = rv
    return rv


def _force_dict(value, silent=False):
    """If the value is not a dict, raise an exception."""
    if value is None:
        return {}
    elif not isinstance(value, dict):
        if silent:
            return {}
        raise DataIntegrityError('expected a dict, got %r' %
                                 value.__class__.__name__)
    return value


def _force_list(value, silent=False):
    """If the value is not a list, raise an exception"""
    if value is None:
        return []
    try:
        if isinstance(value, basestring):
            raise TypeError()
        return list(value)
    except TypeError:
        if silent:
            return []
        raise DataIntegrityError('expected a list, got %r' %
                                 value.__class__.__name__)


def _make_widget(field, name, value, errors):
    """Shortcut for widget creation."""
    return field.widget(field, name, value, errors)


def _make_name(parent, child):
    """Joins a name."""
    if parent is None:
        result = unicode(child)
    else:
        result = u'%s.%s' % (parent, child)

    # try to return a ascii only bytestring
    try:
        return str(result)
    except UnicodeError:
        return result


def _to_string(value):
    """Convert a value to unicode, None means empty string."""
    if value is None:
        return u''
    return unicode(value)


class _HTMLSequence(object):
    """A mixin for iterable objects that yield html."""

    def as_ul(self, **attr):
        return html.ul(*(html.li(unicode(item)) for item in self), **attr)

    def as_ol(self, **attr):
        return html.ol(*(html.li(unicode(item)) for item in self), **attr)


class Widget(object):
    """Baseclass for all widgets."""

    def __init__(self, field, name, value, all_errors):
        self._field = field
        self._value = value
        self._all_errors = all_errors
        self.name = name

    @property
    def value(self):
        return self._field.to_primitive(self._value)

    @property
    def errors(self):
        """The direct errors of this widget."""
        if self.name in self._all_errors:
            return self._all_errors[self.name]
        return ErrorList()

    @property
    def all_errors(self):
        """The current errors and the errors of all child widgets."""
        items = sorted(self._all_errors.items())
        if self.name is None:
            return ErrorList(chain(*(item[1] for item in items)))
        result = ErrorList()
        for key, value in items:
            if key == self.name or key.startswith(self.name + '.'):
                result.extend(value)
        return result

    def __call__(self):
        return u''

    def __unicode__(self):
        return self()

    def __str__(self):
        return unicode(self).encode('utf-8')


class InputWidget(Widget):
    """A widget that is a HTML input field."""
    hide_value = False
    type = None

    def __call__(self, **attrs):
        value = self.value
        if self.hide_value:
            value = u''
        if 'id' not in attrs:
            attrs['id'] = 'f_' + self.name
        return html.input(name=self.name, value=value, type=self.type,
                          **attrs)


class TextWidget(InputWidget):
    """A widget that holds text."""
    type = 'text'


class PasswordWidget(TextWidget):
    """A widget that holds a password."""
    type = 'password'
    hide_value = True


class CheckboxWidget(Widget):
    """A simple checkbox."""

    def __call__(self, **attrs):
        if 'id' not in attrs:
            attrs['id'] = 'f_' + self.name
        return html.input(name=self.name, type='checkbox',
                          checked=self.value, **attrs)


class SelectBoxWidget(Widget):
    """A select box."""

    def __call__(self, **attrs):
        items = []
        for choice in self._field.choices:
            if isinstance(choice, tuple):
                key, value = choice
            else:
                key = value = choice
            items.append(html.option(unicode(value), value=unicode(key),
                                     selected=key == self.value))
        return html.select(name=self.name, *items, **attrs)


class MappingWidget(Widget):
    """Special widget for dict-like fields."""

    def __init__(self, field, name, value, all_errors):
        Widget.__init__(self, field, name, _force_dict(value), all_errors)
        self._subwidgets = {}

    def __getitem__(self, name):
        subwidget = self._subwidgets.get(name)
        if subwidget is None:
            # this could raise a KeyError we pass through
            subwidget = _make_widget(self._field.fields[name],
                                     _make_name(self.name, name),
                                     self._value.get(name),
                                     self._all_errors)
            self._subwidgets[name] = subwidget
        return subwidget

    def as_dl(self, **attr):
        return html.dl(*(html.dt(key.title()) + html.dd(self[key]())
                         for key in self), **attr)

    def __call__(self, *args, **kwargs):
        return self.as_dl(*args, **kwargs)

    def __iter__(self):
        return iter(self._field.fields)


class FormWidget(MappingWidget):
    """A widget for forms."""

    def get_hidden_fields(self):
        """This method is called by the `hidden_fields` property to return
        a list of (key, value) pairs for the special hidden fields.
        """
        fields = []
        if self._field.form.request is not None:
            if self._field.form.csrf_protected:
                fields.append(('_csrf_token', self.csrf_token))
            if self._field.form.redirect_tracking:
                target = self.redirect_target
                if target is not None:
                    fields.append(('_redirect_target', target))
        return fields

    @property
    def hidden_fields(self):
        """The hidden fields as string."""
        return u''.join(html.input(type='hidden', name=name, value=value)
                        for name, value in self.get_hidden_fields())

    @property
    def csrf_token(self):
        """Forward the CSRF check token for templates."""
        return self._field.form.csrf_token

    @property
    def redirect_target(self):
        """The redirect target for this form."""
        return self._field.form.redirect_target

    def __call__(self, action='', method='post', **attrs):
        # support jinja's caller
        caller = attrs.pop('caller', None)
        if caller is not None:
            body = caller()
        else:
            body = self.as_dl()
        hidden = self.hidden_fields
        if hidden:
            # if there are hidden fields we put an invisible div around
            # it.  the HTML standard doesn't allow input fields as direct
            # childs of a <form> tag...
            body = '<div style="display: none">%s</div>%s' % (hidden, body)
        return html.form(body, action=action, method=method, **attrs)


class ListWidget(Widget, _HTMLSequence):
    """Special widget for list-like fields."""

    def __init__(self, field, name, value, all_errors):
        Widget.__init__(self, field, name, _force_list(value), all_errors)
        self._subwidgets = {}

    def __getitem__(self, index):
        if not isinstance(index, (int, long)):
            raise TypeError('list widget indices must be integers')
        subwidget = self._subwidgets.get(index)
        if subwidget is None:
            try:
                value = self._value[index]
            except IndexError:
                # return an widget without value if we try
                # to access a field not in the list
                value = None
            subwidget = _make_widget(self._field.field,
                                     _make_name(self.name, index), value,
                                     self._all_errors)
            self._subwidgets[index] = subwidget
        return subwidget


    def __iter__(self):
        for index in xrange(len(self)):
            yield self[index]

    def __len__(self):
        return len(self._value)

    def __call__(self, *args, **kwargs):
        return self.as_ul(*args, **kwargs)


class ErrorList(list, _HTMLSequence):
    """The class that is used to display the errors."""

    def __call__(self, *args, **kwargs):
        return self.as_ul(*args, **kwargs)

    def __unicode__(self):
        return self()

    def __str__(self):
        return unicode(self).encode('utf-8')


class ValidationError(ValueError):
    """Exception raised when invalid data is encountered."""

    def __init__(self, message):
        if not isinstance(message, (list, tuple)):
            messages = [message]
        Exception.__init__(self, messages[0])
        self.messages = ErrorList(messages)

    def unpack(self, key=None):
        return {key: self.messages}


class MultipleValidationErrors(ValidationError):
    """A validation error subclass for multiple errors raised by
    subfields.  This is used by the mapping and list fields.
    """

    def __init__(self, errors):
        ValidationError.__init__(self, '%d error%s' % (
            len(errors), len(errors) != 1 and 's' or ''
        ))
        self.errors = errors

    def __unicode__(self):
        return ', '.join(map(unicode, self.errors.itervalues()))

    def unpack(self, key=None):
        rv = {}
        for name, error in self.errors.iteritems():
            rv.update(error.unpack(_make_name(key, name)))
        return rv


class Field(object):
    """Abstract field base class."""

    widget = TextWidget
    form = None

    def __init__(self, validators=None, widget=None):
        if validators is None:
            validators = []
        self.validators = validators
        if widget is not None:
            self.widget = widget

    def __call__(self, value):
        value = self.convert(value)
        for validator in self.validators:
            validator(self.form, value)
        return value

    def convert(self, value):
        """This can be overridden by subclasses and performs the value
        conversion.
        """
        return unicode(value)

    def to_primitive(self, value):
        """Convert a value into a primitve (string or a list/dict of lists,
        dicts or strings).

        This method must never fail!
        """
        return _to_string(value)

    def _bind(self, form, memo):
        """Method that binds a field to a form."""
        if self.bound:
            raise TypeError('%r already bound' % type(obj).__name__)
        rv = object.__new__(self.__class__)
        rv.__dict__.update(self.__dict__)
        rv.validators = self.validators[:]
        rv.form = form
        return rv

    @property
    def bound(self):
        """True if the form is bound."""
        return 'form' in self.__dict__

    def __repr__(self):
        rv = object.__repr__(self)
        if self.bound:
            rv = rv[:-1] + ' [bound]>'
        return rv


class Mapping(Field):
    """Apply a set of fields to a dictionary of values.

    >>> field = Mapping(name=TextField(), age=IntegerField())
    >>> field({'name': u'John Doe', 'age': u'42'})
    {'age': 42, 'name': u'John Doe'}
    """

    widget = MappingWidget

    def __init__(self, **fields):
        Field.__init__(self)
        self.fields = fields

    def convert(self, value):
        value = _force_dict(value)
        errors = {}
        result = {}
        for name, field in self.fields.iteritems():
            try:
                result[name] = field(value.get(name))
            except ValidationError, e:
                errors[name] = e
        if errors:
            raise MultipleValidationErrors(errors)
        return result

    def to_primitive(self, value):
        value = _force_dict(value, silent=True)
        result = {}
        for key, field in self.fields.iteritems():
            result[key] = field.to_primitive(value.get(name))
        return result

    def _bind(self, form, memo):
        rv = Field._bind(self, form, memo)
        rv.fields = {}
        for key, field in self.fields.iteritems():
            rv.fields[key] = _bind(field, form, memo)
        return rv


class FormMapping(Mapping):
    """Like a mapping but does csrf protection and stuff."""

    widget = FormWidget

    def convert(self, value):
        if self.form is None:
            raise TypeError('form mapping without form passed is unable '
                            'to convert data')
        if self.form.csrf_protected and self.form.request is not None:
            token = self.form.request.values.get('_csrf_token')
            if token != self.form.csrf_token:
                raise ValidationError(_('Invalid security token submitted.'))
        return Mapping.convert(self, value)


class FormAsField(Mapping):
    """If a form is converted into a field the returned field object is an
    instance of this class.  The behavior is mostly equivalent to a normal
    :class:`Mapping` field with the difference that it as an attribute called
    :attr:`form_class` that points to the form class it was created from.
    """

    def __init__(self):
        raise TypeError('can\'t create %r instances' %
                        self.__class__.__name__)


class Multiple(Field):
    """Apply a single field to a sequence of values.

    >>> field = Multiple(IntegerField())
    >>> field([u'1', u'2', u'3'])
    [1, 2, 3]
    """

    widget = ListWidget

    def __init__(self, field, min_size=None, max_size=None):
        Field.__init__(self)
        self.field = field
        self.min_size = min_size
        self.max_size = max_size

    def convert(self, value):
        value = _force_list(value)
        errors = {}
        if self.min_size is not None and len(value) < self.min_size:
            errors.append(ValidationError(
                ngettext('Please provide at least %d item.',
                         'Please provide at least %d items.',
                         self.min_size) % self.min_size
            ))
        if self.max_size is not None and len(value) > self.max_size:
            errors.append(ValidationError(
                ngettext('Please provide no more than %d item.',
                         'Please provide no more than %d items.',
                         self.max_size) % self.max_size
            ))
        result = []
        for idx, item in enumerate(value):
            try:
                result.append(self.field(item))
            except ValidationError, e:
                errors[idx] = e
        if errors:
            raise MultipleValidationErrors(errors)
        return result

    def to_primitive(self, value):
        return map(self.field.to_primitive, _force_list(value, silent=True))

    def _bind(self, form, memo):
        rv = Field._bind(self, form, memo)
        rv.field = _bind(self.field, form, memo)
        return rv


class TextField(Field):
    """Field for strings.

    >>> field = TextField(required=True, min_length=6)
    >>> field('foo bar')
    u'foo bar'
    >>> field('')
    Traceback (most recent call last):
      ...
    ValidationError: This field is required.
    """

    def __init__(self, required=False, min_length=None, max_length=None,
                 validators=None, widget=None):
        Field.__init__(self, validators, widget)
        self.required = required
        self.min_length = min_length
        self.max_length = max_length

    def convert(self, value):
        value = _to_string(value)
        if self.required and not value:
            raise ValidationError(_('This field is required.'))
        if self.min_length is not None and len(value) < self.min_length:
            raise ValidationError(
                ngettext('Please enter at least %d character.',
                         'Please enter at least %d characters.',
                         self.min_length) % self.min_length
            )
        if self.max_length is not None and len(value) > self.max_length:
            raise ValidationError(
                ngettext('Please enter no more than %d character.',
                         'Please enter no more than %d characters.',
                         self.max_length) % self.max_length
            )
        return value


class DateTimeField(Field):
    """Field for datetime objects.

    >>> field = DateTimeField()
    >>> field('1970-01-12 00:00')
    datetime.datetime(1970, 1, 12, 0, 0)
    
    >>> field('foo')
    Traceback (most recent call last):
      ...
    ValidationError: Please enter a valid date.
    """

    def __init__(self, required=False, rebase=True,
                 validators=None, widget=None):
        Field.__init__(self, validators, widget)
        self.required = required
        self.rebase = rebase

    def convert(self, value):
        if isinstance(value, datetime):
            return value
        value = _to_string(value)
        if not value:
            if self.required:
                raise ValidationError(_('This field is required.'))
            return None
        try:
            return parse_datetime(value, rebase=self.rebase)
        except ValueError:
            raise ValidationError('Please enter a valid date.')

    def to_primitive(self, value):
        if isinstance(value, datetime):
            value = format_system_datetime(value, rebase=self.rebase)
        return value


class ModelField(Field):
    """A field that queries for a model.

    The first argument is the name of the model, the second the named
    argument for `filter_by` (eg: `User` and ``'username'``).

    The error message that is raised if the model does not exist is pretty
    generic by default.  It can be modified by providing a `message` argument
    to the constructor.  ``%(value)s`` is replaced with the value the user
    entered.
    """

    def __init__(self, model, key, required=False, message=None,
                 validators=None, widget=None):
        Field.__init__(self, validators, widget)
        self.model = model
        self.key = key
        self.required = required
        self.message = message

    def convert(self, value):
        if isinstance(value, self.model):
            return value
        if not value:
            if self.required:
                raise ValidationError(_('This field is required.'))
            return None

        rv = self.model.objects.filter_by(**{self.key: value}).first()
        message = self.message
        if message is None:
            message = _('"%(value)s" does not exist.')
        if rv is None:
            raise ValidationError(message % {'value': value})
        return rv


class ChoiceField(Field):
    """A field for multiple choices.

    A choice field accepts some choices that are valid values for it.
    Values are compared after converting to unicode which means that
    ``1 == "1"``:

    >>> field = ChoiceField(choices=[1, 2, 3])
    >>> field('1')
    1
    >>> field('42')
    Traceback (most recent call last):
      ...
    ValidationError: Select a valid choice.

    A choice field also accepts lists of tuples as argument where the
    first item is used for comparing and the second for displaying
    (which is used by the `SelectBoxWidget`):

    >>> field = ChoiceField(choices=[(0, 'inactive', 1, 'active')])
    >>> field('0')
    0

    Because all fields are bound to the form before validation it's
    possible to assign the choices later:

    >>> class MyForm(Form):
    ...     status = ChoiceField()
    ...
    >>> form = MyForm()
    >>> form.fields['status'].choices = [(0, 'inactive', 1, 'active')]
    >>> form.validate({'status': '0'})
    True
    >>> form.data
    {'status': 0}
    """

    widget = SelectBoxWidget

    def __init__(self, required=False, choices=None, validators=None,
                 widget=None):
        Field.__init__(self, validators, widget)
        self.required = required
        self.choices = choices

    def convert(self, value):
        if not value and not self.required:
            return
        for choice in self.choices:
            if isinstance(choice, tuple):
                choice = choice[0]
            # perform type interpolation.  If the key from the choices
            # is a integer (42) and the value is a string ("42") we
            # return the integer.
            if value == choice or unicode(value) == unicode(choice):
                return choice
        raise ValidationError(_('Select a valid choice.'))

    def _bind(self, form, memo):
        rv = Field._bind(self, form, memo)
        if self.choices is not None:
            rv.choices = list(self.choices)
        return rv


class IntegerField(Field):
    """Field for integers.

    >>> field = IntegerField(min_value=0, max_value=99)
    >>> field('13')
    13

    >>> field('thirteen')
    Traceback (most recent call last):
      ...
    ValidationError: Please enter a whole number.

    >>> field('193')
    Traceback (most recent call last):
      ...
    ValidationError: Ensure this value is less than or equal to 99.
    """

    def __init__(self, required=False, min_value=None, max_value=None,
                 validators=None, widget=None):
        Field.__init__(self, validators, widget)
        self.required = required
        self.min_value = min_value
        self.max_value = max_value

    def convert(self, value):
        value = _to_string(value)
        if not value:
            if self.required:
                raise ValidationError(_('This field is required.'))
            return None
        try:
            value = int(value)
        except ValueError:
            raise ValidationError(_('Please enter a whole number.'))

        if self.min_value is not None and value < self.min_value:
            raise ValidationError(_('Ensure this value is greater than or '
                                    'equal to %s.') % self.min_value)
        if self.max_value is not None and value > self.max_value:
            raise ValidationError(_('Ensure this value is less than or equal '
                                    'to %s.') % self.max_value)

        return int(value)


class BooleanField(Field):
    """Field for boolean values.

    >>> field = BooleanField()
    >>> field('1')
    True

    >>> field = BooleanField()
    >>> field('')
    False
    """

    widget = CheckboxWidget

    def convert(self, value):
        return bool(value)

    def to_primitive(self, value):
        if value:
            return '1'
        return ''


class FormMeta(type):
    """Meta class for forms.  Handles form inheritance and registers
    validator functions.
    """

    def __new__(cls, name, bases, d):
        fields = {}
        validator_functions = {}
        root_validator_functions = []

        for base in bases:
            if hasattr(base, '_root_field'):
                # base._root_field is always a FormMapping field
                fields.update(base._root_field.fields)
                root_validator_functions.extend(base._root_field.validators)

        for key, value in d.iteritems():
            if key.startswith('validate_') and callable(value):
                validator_functions[key[9:]] = value
            elif isinstance(value, Field):
                fields[key] = value

        for field_name, func in validator_functions.iteritems():
            if field_name in fields:
                fields[field_name].validators.append(func)

        d['_root_field'] = root = FormMapping(**fields)
        context_validate = d.get('context_validate')
        root.validators.extend(root_validator_functions)
        if context_validate is not None:
            root.validators.append(context_validate)

        return type.__new__(cls, name, bases, d)

    def as_field(cls):
        """Returns a field object for this form.  The field object returned
        is independent of the form and can be modified in the same manner as
        a bound field.
        """
        field = object.__new__(FormAsField)
        field.__dict__.update(cls._root_field.__dict__)
        field.form_class = cls
        field.validators = cls._root_field.validators[:]
        field.fields = cls._root_field.fields.copy()
        return field

    @property
    def validators(cls):
        return cls._root_field.validators

    @property
    def fields(cls):
        return cls._root_field.fields


class Form(object):
    """Form base class.

    >>> class PersonForm(Form):
    ...     name = TextField(required=True)
    ...     age = IntegerField()

    >>> form = PersonForm()
    >>> form.validate({'name': 'johnny', 'age': '42'})
    True
    >>> form.data['name']
    u'johnny'
    >>> form.data['age']
    42

    Let's cause a simple validation error:

    >>> form = PersonForm()
    >>> form.validate({'name': '', 'age': 'fourty-two'})
    False
    >>> print form.errors['age'][0]
    Please enter a whole number.
    >>> print form.errors['name'][0]
    This field is required.

    You can also add custom validation routines for fields by adding methods
    that start with the prefix ``validate_`` and the field name that take the
    value as argument. For example:

    >>> class PersonForm(Form):
    ...     name = TextField(required=True)
    ...     age = IntegerField()
    ...
    ...     def validate_name(self, value):
    ...         if not value.isalpha():
    ...             raise ValidationError('The value must only contain letters')

    >>> form = PersonForm()
    >>> form.validate({'name': 'mr.t', 'age': '42'})
    False
    >>> form.errors
    {'name': ['The value must only contain letters']}

    You can also validate multiple fields in the context of other fields.
    That validation is performed after all other validations.  Just add a
    method called ``context_validate`` that is passed the dict of all fields::

    >>> class RegisterForm(Form):
    ...     username = TextField(required=True)
    ...     password = TextField(required=True)
    ...     password_again = TextField(required=True)
    ...
    ...     def context_validate(self, data):
    ...         if data['password'] != data['password_again']:
    ...             raise ValidationError('The two passwords must be the same')

    >>> form = RegisterForm()
    >>> form.validate({'username': 'admin', 'password': 'blah',
    ...                'password_again': 'blag'})
    ...
    False
    >>> form.errors
    {None: ['The two passwords must be the same']}

    Forms can be used as fields for other forms.  To create a form field of
    a form you can call the `as_field` class method::

    >>> field = RegisterForm.as_field()

    This field can be used like any other field class.  What's important about
    forms as fields is that validators don't get an instance of `RegisterForm`
    passed as `form` / `self` but the form where it's used in if the field is
    used from a form.
    """
    __metaclass__ = FormMeta

    def __init__(self, data=None, id=None, name=None, defaults=None,
                 csrf_protected=True, redirect_tracking=True):
        self.request = get_request()
        self.id = id
        self.name = name
        if defaults is None:
            defaults = {}
        self.defaults = defaults
        self.csrf_protected = csrf_protected
        self.redirect_tracking = redirect_tracking
        self.invalid_redirect_targets = set()

        self._root_field = _bind(self.__class__._root_field, self, {})
        self.reset()

        if data is not None:
            self.validate(raw_data)

    def __getitem__(self, key):
        return self.data[key]

    def __contains__(self, key):
        return key in self.data

    def as_widget(self):
        """Return the form as widget."""
        # if there is submitted data, use that for the widget
        if self.raw_data is not None:
            data = self.raw_data
        # otherwise go with the data from the source (eg: database)
        else:
            data = self.data
        return _make_widget(self._root_field, None, data, self.errors)

    def add_invalid_redirect_target(self, *args, **kwargs):
        """Add an invalid target. Invalid targets are URLs we don't want to
        visit again. For example if a post is deleted from the post edit page
        it's a bad idea to redirect back to the edit page because in that
        situation the edit page would return a page not found.

        This function accepts the same parameters as `url_for`.
        """
        self.invalid_redirect_targets.add(url_for(*args, **kwargs))

    @property
    def redirect_target(self):
        """The back-redirect target for this form."""
        return get_redirect_target(self.invalid_redirect_targets,
                                   self.request)

    def redirect(self, *args, **kwargs):
        """Redirects to the url rule given or back to the URL where we are
        comming from if `redirect_tracking` is enabled.
        """
        target = None
        if self.redirect_tracking:
            target = self.redirect_target
        if target is None:
            target = url_for(*args, **kwargs)
        return redirect(target)

    @property
    def csrf_token(self):
        """The unique CSRF security token for this form."""
        if self.request is None:
            raise AttributeError('no csrf token because form not bound '
                                 'to request')
        path = self.request.path
        user_id = -1
        if self.request.user.is_somebody:
            user_id = self.request.user.user_id
        key = self.request.app.cfg['secret_key']
        return sha1(('%s|%s|%s|%s' % (path, self.id, user_id, key))
                     .encode('utf-8')).hexdigest()

    @property
    def is_valid(self):
        return not self.errors

    @property
    def fields(self):
        return self._root_field.fields

    @property
    def validators(self):
        return self._root_field.validators

    def reset(self):
        self.data = self.defaults.copy()
        self.errors = {}
        self.raw_data = None

    def validate(self, data):
        """Validate the form against the data passed."""
        self.raw_data = _decode(data)
        d = self.data.copy()
        d.update(self.raw_data)
        errors = {}
        try:
            data = self._root_field(d)
        except ValidationError, e:
            errors = e.unpack()
        self.errors = errors
        if errors:
            return False
        self.data.update(data)
        return True
