# -*- coding: utf-8 -*-
"""
    zine.utils.forms
    ~~~~~~~~~~~~~~~~

    The Zine form handling.

    License notice: largely based on diva's form handling.

    :copyright: Copyright 2007-2008 by Armin Ronacher, Christopher Lenz.
    :license: GNU GPL.
"""
import re
from copy import copy
from datetime import datetime
from unicodedata import normalize
from itertools import chain

from werkzeug import html

from zine.i18n import gettext, ngettext, parse_datetime, \
     format_system_datetime


class DataIntegrityError(ValueError):
    """Raised if data was fed to the form handling system that was not
    generated by it.
    """


def _decode(data):
    """Decodes the flat dictionary d into a nested structure.

    >>> _decode({'foo': 'bar'})
    {'foo': 'bar'}

    >>> _decode({'foo.0': 'bar', 'foo.1': 'baz'})
    {'foo': ['bar', 'baz']}

    >>> data = _decode({'foo.bar': '1', 'foo.baz': '2'})
    >>> assert data == {'foo': {'bar': '1', 'baz': '2'}}

    >>> _decode({'foo.bar.0': 'baz', 'foo.bar.1': 'buzz'})
    {'foo': {'bar': ['baz', 'buzz']}}

    >>> _decode({'foo.0.bar': '23', 'foo.1.baz': '42'})
    {'foo': [{'bar': '23'}, {'baz': '42'}]}

    >>> _decode({'foo.0.0': '23', 'foo.0.1': '42'})
    {'foo': [['23', '42']]}

    >>> _decode({'foo': ['23', '42']})
    {'foo': ['23', '42']}
    """
    list_marker = object()
    result = {}
    lists = []

    for key, value in data.iteritems():
        if '.' not in key:
            result[key] = value
        else:
            names = key.split('.')
            container = result
            end = len(names) - 1
            for idx in xrange(end):
                curname = names[idx]
                if curname not in container:
                    nextname = names[idx + 1]
                    container[curname] = {}
                    if nextname.isdigit():
                        container[curname][list_marker] = True
                container = container[curname]
            if isinstance(container, dict):
                container[names[-1]] = value

    def _convert(data):
        if type(data) is dict:
            if data.pop(list_marker, False):
                data = [_convert(v) for k, v in sorted(data.items())]
            else:
                data = dict((k, _convert(v)) for k, v in data.iteritems())
        return data

    return _convert(result)


def _force_dict(value, silent=False):
    """If the value is not a dict, raise an exception."""
    if value is None:
        return {}
    elif not isinstance(value, dict):
        if silent:
            return {}
        raise DataIntegrityError('expected a dict, got %r' %
                                 value.__class__.__name__)
    return value


def _force_list(value, silent=False):
    """If the value is not a list, raise an exception"""
    if value is None:
        return []
    try:
        if isinstance(value, basestring):
            raise TypeError()
        return list(value)
    except TypeError:
        if silent:
            return []
        raise DataIntegrityError('expected a list, got %r' %
                                 value.__class__.__name__)


def _make_widget(field, name, value, errors):
    """Shortcut for widget creation."""
    return field.widget(field, name, value, errors)


def _make_name(parent, child):
    """Joins a name."""
    if parent is None:
        result = unicode(child)
    else:
        result = u'%s.%s' % (parent, child)

    # try to return a ascii only bytestring
    try:
        return str(result)
    except UnicodeError:
        return result


def _to_string(value):
    """Convert a value to unicode, None means empty string."""
    if value is None:
        return u''
    return unicode(value)


class _HTMLSequence(object):
    """A mixin for iterable objects that yield html."""

    def as_ul(self, **attr):
        return html.ul(*(html.li(unicode(item)) for item in self), **attr)

    def as_ol(self, **attr):
        return html.ol(*(html.li(unicode(item)) for item in self), **attr)


class Widget(object):
    """Baseclass for all widgets."""

    def __init__(self, field, name, value, all_errors):
        self._field = field
        self._value = value
        self._all_errors = all_errors
        self.name = name

    @property
    def value(self):
        return self._field.to_primitive(self._value)

    @property
    def errors(self):
        """The direct errors of this widget."""
        if self.name in self._all_errors:
            return self._all_errors[self.name]
        return ErrorList()

    @property
    def all_errors(self):
        """The current errors and the errors of all child widgets."""
        items = sorted(self._all_errors.items())
        if self.name is None:
            return ErrorList(chain(*(item[1] for item in items)))
        result = ErrorList()
        for key, value in items:
            if key == self.name or key.startswith(self.name + '.'):
                result.extend(value)
        return result

    def __call__(self):
        return u''

    def __unicode__(self):
        return self()

    def __str__(self):
        return unicode(self).encode('utf-8')


class InputWidget(Widget):
    """A widget that is a HTML input field."""

    def __call__(self, **attrs):
        return html.input(name=self.name, value=self.value, type=self.type,
                          **attrs)


class TextWidget(InputWidget):
    """A widget that holds text."""
    type = 'text'


class PasswordWidget(TextWidget):
    """A widget that holds a password."""
    type = 'password'


class CheckboxWidget(InputWidget):
    """A simple checkbox."""
    type = 'checkbox'


class MappingWidget(Widget):
    """Special widget for dict-like fields."""

    def __init__(self, field, name, value, all_errors):
        Widget.__init__(self, field, name, _force_dict(value), all_errors)
        self._subwidgets = {}

    def __getitem__(self, name):
        subwidget = self._subwidgets.get(name)
        if subwidget is None:
            # this could raise a KeyError we pass through
            subwidget = _make_widget(self._field.fields[name],
                                     _make_name(self.name, name),
                                     self._value.get(name),
                                     self._all_errors)
            self._subwidgets[name] = subwidget
        return subwidget

    def as_dl(self, **attr):
        return html.dl(*(html.dt(key.title()) + html.dd(self[key]())
                         for key in self), **attr)

    def __call__(self, *args, **kwargs):
        return self.as_dl(*args, **kwargs)

    def __iter__(self):
        return iter(self._field.fields)


class FormWidget(MappingWidget):
    """A widget for forms."""

    def __call__(self, action='', method='post', enctype=None, **attrs):
        # support jinja's caller
        caller = attrs.pop('caller', None)
        if caller is not None:
            body = caller()
        else:
            body = self.as_dl(**attrs)
        return html.form(body, action=action, method=method, enctype=enctype)


class ListWidget(Widget, _HTMLSequence):
    """Special widget for list-like fields."""

    def __init__(self, field, name, value, all_errors):
        Widget.__init__(self, field, name, _force_list(value), all_errors)
        self._subwidgets = {}

    def __getitem__(self, index):
        if not isinstance(index, (int, long)):
            raise TypeError('list widget indices must be integers')
        subwidget = self._subwidgets.get(index)
        if subwidget is None:
            try:
                value = self._value[index]
            except IndexError:
                # return an widget without value if we try
                # to access a field not in the list
                value = None
            subwidget = _make_widget(self._field.field,
                                     _make_name(self.name, index), value,
                                     self._all_errors)
            self._subwidgets[index] = subwidget
        return subwidget


    def __iter__(self):
        for index in xrange(len(self)):
            yield self[index]

    def __len__(self):
        return len(self._value)

    def __call__(self, *args, **kwargs):
        return self.as_ul(*args, **kwargs)


class ErrorList(list, _HTMLSequence):
    """The class that is used to display the errors."""

    def __call__(self, *args, **kwargs):
        return self.as_ul(*args, **kwargs)

    def __unicode__(self):
        return self()

    def __str__(self):
        return unicode(self).encode('utf-8')


class ValidationError(ValueError):
    """Exception raised when invalid data is encountered."""

    def __init__(self, message):
        if not isinstance(message, (list, tuple)):
            messages = [message]
        Exception.__init__(self, messages[0])
        self.messages = ErrorList(messages)

    def unpack(self, key=None):
        return {key: self.messages}


class MultipleValidationErrors(ValidationError):
    """A validation error subclass for multiple errors raised by
    subfields.  This is used by the mapping and list fields.
    """

    def __init__(self, errors):
        ValidationError.__init__(self, '%d error%s' % (
            len(errors), len(errors) != 1 and 's' or ''
        ))
        self.errors = errors

    def __unicode__(self):
        return ', '.join(map(unicode, self.errors.itervalues()))

    def unpack(self, key=None):
        rv = {}
        for name, error in self.errors.iteritems():
            rv.update(error.unpack(_make_name(key, name)))
        return rv


class Converter(object):
    """Internal baseclass for fields."""

    def __init__(self, validators=None):
        if validators is None:
            validators = []
        self.validators = validators

    def __call__(self, value, form=None):
        value = self.convert(value, form)
        for validator in self.validators:
            validator(form, value)
        return value

    def convert(self, value, form):
        """This can be overridden by subclasses and performs the value
        conversion.  If the converting process is triggered without a form
        the form parameter will be `None`.
        """
        return unicode(value)

    def to_primitive(self, value):
        """Convert a value into a primitve (string or a list/dict of lists,
        dicts or strings).

        This method must never fail!
        """
        return _to_string(value)

    def clone(self):
        """Creates a clone of the converter."""
        rv = object.__new__(self.__class__)
        for key, value in self.__dict__.iteritems():
            rv.__dict__[key] = copy(value)
        return rv

    def __copy__(self):
        return self.clone()


class Field(Converter):
    """Abstract field base class."""

    # set later for all classes
    widget = TextWidget

    def __init__(self, validators=None, widget=None):
        Converter.__init__(self, validators)
        if widget is not None:
            self.widget = widget


class Mapping(Field):
    """Apply a set of fields to a dictionary of values.

    >>> field = Mapping(name=TextField(), age=IntegerField())
    >>> field({'name': u'John Doe', 'age': u'42'})
    {'age': 42, 'name': u'John Doe'}
    """

    widget = MappingWidget

    def __init__(self, **fields):
        Field.__init__(self)
        self.fields = fields

    def convert(self, value, form):
        errors = {}
        result = {}
        for name, field in self.fields.iteritems():
            try:
                result[name] = field(value.get(name, u''), form)
            except ValidationError, e:
                errors[name] = e
        if errors:
            raise MultipleValidationErrors(errors)
        return result

    def to_primitive(self, value):
        # whoops.  that value is not a dict.  We have no idea how to
        # fall back here, return an empty mapping
        if not isinstance(value, dict):
            return {}
        result = {}
        for key, field in self.fields.iteritems():
            result[key] = field.to_primitive(value.get(name, u''))
        return result

    def __repr__(self):
        return '<%s %r>' % (self.__class__.__name__, self.fields)


class FormAsField(Mapping):
    """If a form is converted into a field the returned field object is an
    instance of this class.  The behavior is mostly equivalent to a normal
    :class:`Mapping` field with the difference that it as an attribute called
    :attr:`form_class` that points to the form class it was created from.
    """

    widget = FormWidget

    def __init__(self):
        raise TypeError('can\'t create %r instances' %
                        self.__class__.__name__)


class Multiple(Field):
    """Apply a single field to a sequence of values.

    >>> field = Multiple(IntegerField())
    >>> field([u'1', u'2', u'3'])
    [1, 2, 3]
    """

    widget = ListWidget

    def __init__(self, field, min_size=None, max_size=None):
        Field.__init__(self)
        self.field = field
        self.min_size = min_size
        self.max_size = max_size

    def convert(self, value, form):
        errors = {}
        if self.min_size is not None and len(value) < self.min_size:
            errors.append(ValidationError(
                ngettext('Please provide at least %d item.',
                         'Please provide at least %d items.',
                         self.min_size) % self.min_size
            ))
        if self.max_size is not None and len(value) > self.max_size:
            errors.append(ValidationError(
                ngettext('Please provide no more than %d item.',
                         'Please provide no more than %d items.',
                         self.max_size) % self.max_size
            ))
        result = []
        for idx, item in enumerate(value):
            try:
                result.append(self.field(item, form))
            except ValidationError, e:
                errors[idx] = e
        if errors:
            raise MultipleValidationErrors(errors)
        return result

    def to_primitive(self, value):
        return map(self.field.to_primitive, _force_list(value, silent=True))

    def __repr__(self):
        return '<%s %r>' % (self.__class__.__name__, self.field)


class TextField(Field):
    """Field for strings.

    >>> field = TextField(required=True, min_length=6)
    >>> field('foo bar')
    u'foo bar'
    >>> field('')
    Traceback (most recent call last):
      ...
    ValidationError: This field is required.
    """

    def __init__(self, required=False, min_length=None, max_length=None,
                 validators=None, widget=None):
        Field.__init__(self, validators, widget)
        self.required = required
        self.min_length = min_length
        self.max_length = max_length

    def convert(self, value, form):
        value = _to_string(value)
        if self.required and not value:
            raise ValidationError(gettext('This field is required.'))
        if self.min_length is not None and len(value) < self.min_length:
            raise ValidationError(
                ngettext('Please enter at least %d character.',
                         'Please enter at least %d characters.',
                         self.min_length) % self.min_length
            )
        if self.max_length is not None and len(value) > self.max_length:
            raise ValidationError(
                ngettext('Please enter no more than %d character.',
                         'Please enter no more than %d characters.',
                         self.max_length) % self.max_length
            )
        return value


class DateTimeField(Field):
    """Field for datetime objects.

    >>> field = DateTimeField()
    >>> field('1970-01-12 00:00')
    datetime.datetime(1970, 1, 12, 0, 0)
    
    >>> field('foo')
    Traceback (most recent call last):
      ...
    ValidationError: Please enter a valid date.
    """

    def __init__(self, required=False, rebase=True,
                 validators=None, widget=None):
        Field.__init__(self, validators, widget)
        self.required = required
        self.rebase = rebase

    def convert(self, value, form):
        if isinstance(value, datetime):
            return value
        value = _to_string(value)
        if not value:
            if requried:
                raise ValidationError(gettext('This field is required.'))
            return None
        try:
            return parse_datetime(value, rebase=self.rebase)
        except ValueError:
            raise ValidationError('Please enter a valid date.')

    def to_primitive(self, value):
        if isinstance(value, datetime):
            value = format_system_datetime(value, rebase=self.rebase)
        return value


class IntegerField(Field):
    """Field for integers.

    >>> field = IntegerField(min_value=0, max_value=99)
    >>> field('13')
    13

    >>> field('thirteen')
    Traceback (most recent call last):
      ...
    ValidationError: Please enter a whole number.

    >>> field('193')
    Traceback (most recent call last):
      ...
    ValidationError: Ensure this value is less than or equal to 99.
    """

    def __init__(self, required=False, min_value=None, max_value=None,
                 validators=None, widget=None):
        Field.__init__(self, validators, widget)
        self.required = required
        self.min_value = min_value
        self.max_value = max_value

    def convert(self, value, form):
        value = _to_string(value)
        if not value:
            if self.required:
                raise ValidationError(gettext('This field is required.'))
            return None
        try:
            value = int(value)
        except ValueError:
            raise ValidationError(gettext('Please enter a whole number.'))

        if self.min_value is not None and value < self.min_value:
            raise ValidationError(
                gettext('Ensure this value is greater than or equal to '
                        '%s.') % self.min_value
            )
        if self.max_value is not None and value > self.max_value:
            raise ValidationError(
                gettext('Ensure this value is less than or equal to '
                        '%s.') % self.max_value
            )

        return int(value)


class BooleanField(Field):
    """Field for boolean values.

    >>> field = BooleanField()
    >>> field('1')
    True

    >>> field = BooleanField()
    >>> field('')
    False
    """

    widget = CheckboxWidget

    def convert(self, value, form):
        return bool(value)

    def to_primitive(self, value):
        if value:
            return '1'
        return ''


class FormMeta(type):
    """Meta class for forms.  Handles form inheritance and registers
    validator functions.
    """

    def __new__(cls, name, bases, d):
        fields = {}
        validator_functions = {}

        for base in bases:
            if hasattr(base, '_root_field'):
                # base._root_field is always a Mapping field
                fields.update(base._root_field.fields)

        for key, value in d.iteritems():
            if key.startswith('validate_') and callable(value):
                validator_functions[key[9:]] = value
            elif isinstance(value, Field):
                fields[key] = value

        for field_name, func in validator_functions.iteritems():
            if field_name in fields:
                fields[field_name].validators.append(func)

        d['_root_field'] = root = Mapping(**fields)
        context_validate = d.get('context_validate')
        if context_validate is not None:
            root.validators.append(context_validate)

        return type.__new__(cls, name, bases, d)

    def as_field(cls):
        """Returns a field object for this form."""
        field = cls._root_field.clone()
        field.__class__ = FormAsField
        field.form_class = cls
        return field


class Form(object):
    """Form base class.

    >>> class PersonForm(Form):
    ...     name = TextField(required=True)
    ...     age = IntegerField()

    >>> form = PersonForm()
    >>> form.validate({'name': 'johnny', 'age': '42'})
    True
    >>> form.data['name']
    u'johnny'
    >>> form.data['age']
    42

    Let's cause a simple validation error:

    >>> form = PersonForm()
    >>> form.validate({'name': '', 'age': 'fourty-two'})
    False
    >>> print form.errors['age'][0]
    Please enter a whole number.
    >>> print form.errors['name'][0]
    This field is required.

    You can also add custom validation routines for fields by adding methods
    that start with the prefix ``validate_`` and the field name that take the
    value as argument. For example:

    >>> class PersonForm(Form):
    ...     name = TextField(required=True)
    ...     age = IntegerField()
    ...
    ...     def validate_name(self, value):
    ...         if not value.isalpha():
    ...             raise ValidationError('The value must only contain letters')

    >>> form = PersonForm()
    >>> form.validate({'name': 'mr.t', 'age': '42'})
    False
    >>> form.errors
    {'name': ['The value must only contain letters']}

    You can also validate multiple fields in the context of other fields.
    That validation is performed after all other validations.  Just add a
    method called ``context_validate`` that is passed the dict of all fields::

    >>> class RegisterForm(Form):
    ...     username = TextField(required=True)
    ...     password = TextField(required=True)
    ...     password_again = TextField(required=True)
    ...
    ...     def context_validate(self, data):
    ...         if data['password'] != data['password_again']:
    ...             raise ValidationError('The two passwords must be the same')

    >>> form = RegisterForm()
    >>> form.validate({'username': 'admin', 'password': 'blah',
    ...                'password_again': 'blag'})
    ...
    False
    >>> form.errors
    {None: ['The two passwords must be the same']}

    Forms can be used as fields for other forms.  To create a form field of
    a form you can call the `as_field` class method::

    >>> field = RegisterForm.as_field()

    This field can be used like any other field class.  What's important about
    forms as fields is that validators don't get an instance of `RegisterForm`
    passed as `form` / `self` but the form where it's used in if the field is
    used from a form.
    """
    __metaclass__ = FormMeta

    def __init__(self, data=None, id=None, name=None, defaults=None):
        self.id = id
        self.name = name
        if defaults is None:
            defaults = {}
        self.defaults = defaults
        self.reset()
        if data is not None:
            self.validate(raw_data)

    def as_widget(self):
        """Return the form as widget."""
        # if there is submitted data, use that for the widget
        if self.raw_data is not None:
            data = self.raw_data
        # otherwise go with the data from the source (eg: database)
        else:
            data = self.data
        return FormWidget(self._root_field, None, data, self.errors)

    @property
    def fields(self):
        return self._root_field.fields

    def reset(self):
        self.data = self.defaults.copy()
        self.errors = {}
        self.raw_data = None

    @property
    def is_valid(self):
        return not self.errors

    def validate(self, data):
        """Validate the form against the data passed."""
        self.raw_data = _decode(data)
        d = self.data.copy()
        d.update(self.raw_data)
        errors = {}
        try:
            data = self._root_field(d)
        except ValidationError, e:
            errors = e.unpack()
        self.errors = errors
        if errors:
            return False
        self.data.update(data)
        return True
